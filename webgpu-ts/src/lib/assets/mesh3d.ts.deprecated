export class Mesh3D {
  // Typical GPU cache line size is 128 bytes or 64 bytes.
  // Stride: (position: vec3f, normal: vec3f, uv: vec2f)
  //   (3+3+2)=8 float32 = 32 bytes, aligns well with cache line.
  static readonly stride = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
  static readonly shaderAttributes: GPUVertexAttribute[] = [
    { shaderLocation: 0, offset: 0 * 4, format: "float32x3" }, // position
    { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
    { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
  ];

  static createRenderPipeline(device: GPUDevice): GPURenderPipeline {
    const shaders = device.createShaderModule({ code: shadersSource });
    return device.createRenderPipeline({
      label: "Mesh3D render pipeline",
      layout: "auto",
      vertex: {
        module: shaders,
        buffers: [
          {
            arrayStride: Mesh3D.stride,
            stepMode: "vertex",
            attributes: Mesh3D.shaderAttributes,
          },
        ],
      },
      fragment: {
        module: shaders,
        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }],
      },
      primitive: {
        topology: "triangle-list", // default
        cullMode: "back",
      },
    });
  }
}

const shadersSource = /* wgsl */ `
  struct Uniforms {
    transform: mat4x4f,
  };
  @group(0) @binding(0) var<uniform> uni: Uniforms;

  struct VertexInput {
    @location(0) position: vec3f,
    @location(1) normal: vec3f,
    @location(2) uv: vec2f,
  };

  struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) normal: vec3f,
  };

  @vertex fn vs(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    output.position = uni.transform * vec4f(input.position, 1.0);
    output.normal = input.normal;
    return output;
  }

  @fragment fn fs(input: VertexOutput) -> @location(0) vec4f {
    // return uni.color;
    // return vec4f(1, 1, 1, 1);
    return vec4f(input.normal * 0.5 + 0.5, 1);
  }
`;
