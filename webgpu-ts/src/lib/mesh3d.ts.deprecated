// const FLOAT16_SIZE = 2; // bytes
// const FLOAT32_SIZE = 4; // bytes

import { mat4 } from "./mat4";

export class Mesh3D {
  readonly device: GPUDevice;
  readonly name: string;
  readonly pipeline: GPURenderPipeline;
  readonly uniformBuffer: GPUBuffer;
  readonly bindGroup: GPUBindGroup;
  readonly vertexBuffer: GPUBuffer;
  readonly vertexCount: number;
  readonly indexBuffer: GPUBuffer;
  readonly indexCount: number;
  readonly instances: number;

  uniforms: Float32Array<ArrayBuffer>;

  constructor(
    device: GPUDevice,
    args: {
      name: string;
      vertexData: Float32Array<ArrayBuffer>;
      vertexCount: number;
      indexData: Uint16Array<ArrayBuffer>;
      indexCount: number;
      instances?: number;
    },
  ) {
    this.device = device;
    this.name = args.name;

    // Render pipeline
    const shaders = device.createShaderModule({ code: shadersSource });
    this.pipeline = device.createRenderPipeline({
      label: `[${this.name}] render pipeline`,
      layout: "auto",
      vertex: {
        module: shaders,
        buffers: [
          {
            // Vertex data format:
            // (vertex: vec3, normals: vec3, uv: vec2) = 8 floats
            arrayStride: (3 + 3 + 2) * 4, // 8 floats * 4 bytes each
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0 * 4, format: "float32x3" }, // position
              { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
              { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
            ],
          },
        ],
      },
      fragment: {
        module: shaders,
        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }],
      },
      primitive: {
        // topology: "triangle-list", // default
        cullMode: "back",
      },
      // depthStencil: {
      //   depthWriteEnabled: true,
      //   depthCompare: "less",
      //   format: "depth24plus",
      // },
    });

    // Uniforms (globals + locals)
    this.uniforms = new Float32Array(4 * 4);
    this.uniformBuffer = device.createBuffer({
      label: `[${this.name}] uniform buffer`,
      size: this.uniforms.byteLength,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    this.bindGroup = device.createBindGroup({
      label: `[${this.name}] bind group`,
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [{ binding: 0, resource: { buffer: this.uniformBuffer } }],
    });

    // Vertex buffer
    this.vertexBuffer = device.createBuffer({
      label: `[${this.name}] vertex buffer`,
      size: args.vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(this.vertexBuffer, 0, args.vertexData);
    this.vertexCount = args.vertexCount;

    // Index buffer
    this.indexBuffer = device.createBuffer({
      label: `[${this.name}] index buffer`,
      size: args.indexData.byteLength,
      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(this.indexBuffer, 0, args.indexData);
    this.indexCount = args.indexCount;

    // Instances
    this.instances = args.instances ?? 1;
  }

  getViewMatrix(): Float32Array<ArrayBuffer> {
    return this.uniforms.subarray(0, 4 * 4);
  }

  getTransform(i: number): Float32Array<ArrayBuffer> {
    return this.uniforms.subarray(0, 4 * 4);
  }

  translate(translation: number[], instance?: number) {
    const transform = this.getTransform(instance ?? 0);
    mat4.translate(transform, translation, transform);
  }

  rotate(rotation: number[], instance?: number) {
    const transform = this.getTransform(instance ?? 0);
    mat4.rotateX(transform, rotation[0], transform);
    mat4.rotateY(transform, rotation[1], transform);
    mat4.rotateZ(transform, rotation[2], transform);
  }

  scale(scale: number[], instance?: number) {
    const transform = this.getTransform(instance ?? 0);
    mat4.scale(transform, scale, transform);
  }

  render(pass: GPURenderPassEncoder) {
    this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniforms);

    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup); // uniforms
    pass.setVertexBuffer(0, this.vertexBuffer);
    pass.setIndexBuffer(this.indexBuffer, "uint16");
    pass.drawIndexed(this.indexCount);
  }

  static from(
    device: GPUDevice,
    args: {
      name: string;
      vertices: number[][];
      indices: number[];
    },
  ): Mesh3D {
    // The WebGPU specification requires the index buffer to be a
    // multiple of 4 bytes. If we have an odd number of uint16 indices,
    // it requires a 2 byte padding (1 extra element).
    // Therefore, we must keep track of the real length in indexCount.
    const padding = args.indices.length % 2 === 0 ? [] : [0];
    return new Mesh3D(device, {
      name: args.name,
      vertexCount: args.vertices.length,
      vertexData: new Float32Array(args.vertices.flat()),
      indexCount: args.indices.length,
      indexData: new Uint16Array(args.indices.concat(padding)),
    });
  }

  static renderPipeline(device: GPUDevice): GPURenderPipeline {
    const shaders = device.createShaderModule({ code: shadersSource });
    return device.createRenderPipeline({
      label: "Mesh3D render pipeline",
      layout: "auto",
      vertex: {
        module: shaders,
        buffers: [
          {
            // Vertex data format:
            // (vertex: vec3, normals: vec3, uv: vec2) = 8 floats
            arrayStride: (3 + 3 + 2) * 4, // 8 floats * 4 bytes each
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0 * 4, format: "float32x3" }, // position
              { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
              { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
            ],
          },
        ],
      },
      fragment: {
        module: shaders,
        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }],
      },
      primitive: {
        topology: "triangle-list", // default
        cullMode: "back",
      },
    });
  }
}

const shadersSource = /* wgsl */ `
  struct Uniforms {
    transform: mat4x4f,
  };
  @group(0) @binding(0) var<uniform> uni: Uniforms;

  struct VertexInput {
    @location(0) position: vec3f,
    @location(1) normal: vec3f,
    @location(2) uv: vec2f,
  };

  struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) normal: vec3f,
  };

  @vertex fn vs(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    output.position = uni.transform * vec4f(input.position, 1.0);
    output.normal = input.normal;
    return output;
  }

  @fragment fn fs(input: VertexOutput) -> @location(0) vec4f {
    // return uni.color;
    // return vec4f(1, 1, 1, 1);
    return vec4f(input.normal * 0.5 + 0.5, 1);
  }
`;
